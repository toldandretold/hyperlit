<p>IndexedDB Structure mm</p>
<h2>macro units</h2>
<ol>
<li>DOM - can be saved to indexedDB per <div data-chunk-id="">, after visible data-chunk-id is updated. </li>
</ol>
<p>This is done so that, if user returns to browser and DOM has not been cached, dont' need to re-initialize lazy loading, or load from nodeChunks, can just insert the last visible data-chunk-id as pre-rendered html, and then begin listening for sentinels etc. </p>
<ol start="2">
<li>IndexedDB parses nodeChunks.json into structured data storage so that IndexedDB can be updated on a line-by-line basis on front end. This means that front end creates the time-stamp, and sends this to back-end. And this means that page-refreshing should be minimal and users can work offline. </li>
</ol>
<p>nodeChunks.json is initially created by parseing main-text.md into chunks, nodes, line-numbers, md-content, hyperlights, and hypercites. </p>
<p>The hyperlights and hypercites store the hyperlight_ids and hypercite_ids of the md content.</p>
<p>These ideas refer to, or are links other indexedDB databases: hyperlights and hyperictes. </p>
<p>There, each hyperlight and hypercite has the start-line-number, end-line-number, character-count start, and character-count end. </p>
<h1>updating IndexedDB</h1>
<h2>macro workflow of front-end to back-end</h2>
<p>If the indexedDB is intialised correctly, any highlight or hypercite that is added or removed can trigger an update of the IndexedDB, on the front end.</p>
<p>When a certain time has elapsed after the indexedDB has been updated, the changs will be batched and sent to back-end, along with a time-stamp, from the front end. </p>
<p>Thus, the back-end is mostly used for saving the .json files, according to the front end. The <strong>advantage of this</strong> is that, on page load, the timestamps should rarely not match, and so the user should only need a hard re-load when moving to a diff browser, or when they have edited their md files locally on a plain text editor like obsidian. </p>
<h2>micro workflow on front-end</h2>
<h3>Adjusting line-number on update</h3>
<p>IndexedDB needs to be initialised such that the line-number value of each md-content (stored by line), is automatically updated when a new line/html-node is inserted or deleted. </p>
<p>This can happen because all html nodes in the Dom receive an id that matches the md line number initially given in nodeChunks.json, and stored in the IndexedDB structure.</p>
<p>So, say user inserts a new html paragraph between html-nodes 17 and 18, that needs to insert in the indexedDB database between these entries, and re-number by one all those following it. </p>
<p>If one is deleted, all those following need to have that number reduced by one. </p>
<h3>adjusting character counts on update</h3>
<p>A similar function needs to take place when content is changed within a line. This is for hyperlights and hypercites. So, lets say that we have a hyperlight with start-value of (5, 3). This represents line 5 and character 3. and an end-value of (6, 5), which represents line 6 and character 5.</p>
<p>If user deletes characters before the highlight, say character (5,1), then the start-value of the highlight needs to be reduced to (5,2). if characters within the highlight are changed, then the end-value may need to be changed. </p>
<p>exmaple of structure:</p>
<p>{
url: &quot;<a href="https://example.com">https://example.com</a>&quot;,
container: &quot;main&quot;,
book: &quot;book1&quot;,
lineNumber: 50,  // This indicates the start line for this record
chunk_id: 1,
blocks: [
{
type: &quot;paragraph&quot;,
content: &quot;Some markdown content for this line&quot;,
startLine: 50,
}
],
hyperlights: [
{
hyperlight_id: &quot;hl-1234&quot;,
Start: yes/no,
Middle: yes/no,
End: yes/no
}
],
hypercites: [
{
hyperlight_id: &quot;hl-1234&quot;,
Start: yes/no,
Middle: yes/no,
End: yes/no
}
],
footnotes: [
{
md: &quot;[^66]&quot;,
content: &quot;The content to be displayed.&quot;
}
]
}</p>